<p data-pid=\"8mdbN8TV\">虽然并没有提到 element3 </p><p data-pid=\"7yKNIH7y\">但是这里还是要说一下我们团队的开发规范：</p><p data-pid=\"baZ6_IyN\"><b>优先选择 template ，当 template 写起来贼费劲时上 tsx</b></p><p data-pid=\"XR41IyRl\">其实这个也是官方推荐的。</p><p data-pid=\"JRewBOg8\">“Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。”</p><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/render-function.html%23ad\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">[传送门](https://cn.vuejs.org/v2/guide/render-function.html#ad)</a><p data-pid=\"lerslSeL\">首先我们先对比一下 template 和 jsx/tsx 的优缺点</p><p data-pid=\"71YFCN0u\"><b>template</b>：</p><p data-pid=\"wpUHU-sB\">优点：</p><ul><li data-pid=\"PwmevEB_\">可读性高</li><ul><li data-pid=\"Y44hs3ui\">基于 dom 结构，很容易就可以看清楚代码要表达的意图（当然，写的一窝粥的除外）</li><li data-pid=\"5lIezeDz\">通过 vue 的指令和语法，一眼就能确定逻辑在哪里</li></ul></ul><p data-pid=\"7xydNxRf\">缺点：</p><ul><li data-pid=\"aGzoPH5Q\">不够灵活</li><ul><li data-pid=\"qvGNLIYb\">也是一直被大家吐槽的点，过于笨重</li></ul><li data-pid=\"PyXAbv_t\">SFC 享受不到 props 类型提示</li><ul><li data-pid=\"THBADwT6\">受限于 SFC，组件在外部使用时 vscode 无法做出 props 的类型提示</li><li data-pid=\"AotzWyjS\">这一点对于组件库来讲是个痛点，我希望用户在使用组件时可以享受到 props 的类型提示</li></ul></ul><p data-pid=\"rNGECorU\"><b>jsx/tsx</b>:</p><p data-pid=\"2G2OLS78\">优点：</p><ul><li data-pid=\"P_I7QhNQ\">灵活</li><ul><li data-pid=\"INiwGDHq\">可以利用 js 来表达各种各样的逻辑，十分灵活</li></ul><li data-pid=\"mEFxRFqx\">可享受 props 类型提示</li><ul><li data-pid=\"XgE-5vfO\">如果是用 tsx 编写的组件，用户是可以享受到 props 的类型提示的</li></ul></ul><p data-pid=\"8k96Njup\">缺点：</p><ul><li data-pid=\"xloGvF9p\">编译优化？</li><ul><li data-pid=\"a5mIRsgx\">这一点也是大家质疑的点，担心如果使用 jsx 的话，是不是享受不到模板编译的优化了</li><li data-pid=\"n_wHzYgU\">如果按照 @vue/babel-plugin-jsx 这个插件提供的 explorer 来看的话是可以享受到模板编译优化的</li><li data-pid=\"liyWK1fc\">但是我用 vue-cli 创建了一个新的 vue3 项目，从编译结果上来看，并没有享受到编译优化，不知道是后续会更新，还是有 bug</li><li data-pid=\"AjyP3Ury\">在 element3 中使用的是 rollup 来打包，对应用 jsx/tsx 编写的组件是享受到编译优化了</li><li data-pid=\"AqLllH5y\">所以这一块是没啥问题的，当然还不能确定用 jsx 可以得到和用 template 同等的编译优化（特殊情况下是否还会有编译优化呢）</li></ul></ul><a data-draft-node=\"block\" data-draft-type=\"link-card\" href=\"https://link.zhihu.com/?target=https%3A//vue-next-jsx-explorer.netlify.app/%23const%2520App%2520%253D%2520defineComponent%28%257B%250A%2520%2520props%253A%2520%255B%2522title%2522%252C%2520%2522offset%2522%252C%2520%2522heihei%2522%255D%252C%250A%2520%2520setup%28%29%2520%257B%250A%2520%2520%2520%2520return%2520%257B%257D%253B%250A%2520%2520%257D%252C%250A%2520%2520render%28ctx%29%2520%257B%250A%2520%2520%2520%2520return%2520%28%250A%2520%2520%2520%2520%2520%2520%253Cdiv%2520title%253D%257Bctx.title%257D%2520data-offset%253D%257Bctx.offset%257D%253E%250A%2520%2520%2520%2520%2520%2520%2520%2520Counter%250A%2520%2520%2520%2520%2520%2520%253C%252Fdiv%253E%250A%2520%2520%2520%2520%29%253B%250A%2520%2520%257D%252C%250A%257D\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://vue-next-jsx-explorer.netlify.app</a><ul><li data-pid=\"O2M2DODK\">可读性差</li><ul><li data-pid=\"H01twmPg\">这个其实也是过于灵活带来的后遗症，就是因为太灵活了，大家怎么写的都有，很容易出现坏味道</li><li data-pid=\"jPD9qF6T\">要不就在 setup 中通过函数返回，要不就在 render 函数中实现，</li><ul><li data-pid=\"h-VUknqu\">但是如果你在 setup 中直接返回的话，其实是破坏了 setup 返回对象作为 view 和 model 层的接口，而且如果是 ref 类型的响应式对象的话，你还必须使用 .value ,享受不到结构 ref 了。你会发现你的代码可读性极差，</li><li data-pid=\"ToalxJR0\">我更推荐在 render 中实现</li><ul><li data-pid=\"UKQtKQ-L\">但是你调用的时候必须要加个 render(ctx), ctx 相当于是 this，还是不如在 template 中干净</li></ul></ul></ul></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span></span><span class=\"c1\">// setup 直接返回一个函数</span>\n<span class=\"kr\">const</span> <span class=\"nx\">Foo</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n   <span class=\"nx\">setup</span><span class=\"p\">(){</span>\n    <span class=\"kr\">const</span> <span class=\"nx\">count</span> <span class=\"o\">=</span> <span class=\"nx\">ref</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> \n    \n    <span class=\"c1\">// 返回一个函数</span>\n    <span class=\"c1\">// 如果是返回一个对象的话，这个对象其实可以看做 view 和 model 之间的接口层，但是返回一个函数的话，就破坏了</span>\n    <span class=\"c1\">// 必须对 ref 类型的响应式对象使用 .value</span>\n    <span class=\"k\">return</span> <span class=\"p\">()=&gt;{</span>\n      <span class=\"o\">&lt;</span><span class=\"nx\">div</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"nx\">count</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">}</span><span class=\"o\">&lt;</span><span class=\"err\">/div&gt;</span>\n    <span class=\"p\">}</span>\n   <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><br></p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>// render 中实现\nconst Foo = {\n   setup(){\n    const count = ref(0) \n    return {count}\n   },\n   render(ctx){\n     // 必须调用 ctx\n     return &lt;div&gt;{ctx.count}&lt;/div&gt;\n   }\n}\n</code></pre></div><p><br></p><p data-pid=\"9MUbWHh0\">至于为什么别的组件库都用 jsx/tsx 的问题，其实很多组件库都有之前的包袱，为了可以快速的支持 vue3 ，基本上就是改一改废弃的语法，别报错，能跑起来即可</p><p data-pid=\"FP36-I9V\">所以如果之前组件库是用 jsx/tsx 写的，你会发现现在依然是</p><p data-pid=\"F3MEPBmN\">如果之前组件库是用 options api 写的，你会发现现在依然是</p><p data-pid=\"uHpQFZ4s\">当然了，现在这个阶段大家也都在积极的切到 composition api 上去。</p><p><br></p><p data-pid=\"TB_DUD7r\">对于我来讲 可读性大于灵活性</p><p data-pid=\"LSge5lK0\">而且 templete 会享受到所有的编译优化</p><p data-pid=\"We6G9KEF\">不管是从可读性上还是性能上我都推荐优先使用 templete 。</p><p data-pid=\"e9WQIGhl\">当逻辑必须要用 jsx/tsx 来实现的话 在上</p>